"""Swerve drivetrain using CTRE Phoenix 6 swerve API."""

import math

from choreo.trajectory import SwerveSample
from magicbot import feedback
from phoenix6 import swerve
from phoenix6.hardware import CANcoder, TalonFX
from wpilib import Field2d, RobotBase, RobotController, SmartDashboard
from wpimath.controller import PIDController
from wpimath.geometry import Pose2d, Rotation2d
from wpimath.kinematics import ChassisSpeeds
from wpimath.units import meters_per_second, radians_per_second

from generated.tuner_constants import TunerConstants

# Simulation period in seconds (20ms = 0.020s for standard robot loop)
SIM_LOOP_PERIOD = 0.020


class Drivetrain:
    """Swerve drivetrain wrapper using CTRE Phoenix 6 SwerveDrivetrain.

    This class wraps the Phoenix 6 SwerveDrivetrain to integrate with MagicBot's
    component system. The Phoenix 6 API handles all the low-level control.

    Configuration is loaded from generated/tuner_constants.py which is designed
    to be regenerated by Phoenix Tuner X's Swerve Project Generator.
    """

    # PID gains for trajectory following - tune these for your robot!
    # These provide feedback to correct position error during trajectory following
    TRAJECTORY_X_KP = 10.0
    TRAJECTORY_Y_KP = 10.0
    TRAJECTORY_HEADING_KP = 7.5

    def __init__(self) -> None:
        """Initialize the swerve drivetrain with all modules."""
        # Create the Phoenix 6 SwerveDrivetrain using TunerConstants
        self._drivetrain = swerve.SwerveDrivetrain(
            TalonFX,
            TalonFX,
            CANcoder,
            TunerConstants.drivetrain_constants,
            [
                TunerConstants.front_left,
                TunerConstants.front_right,
                TunerConstants.back_left,
                TunerConstants.back_right,
            ],
        )

        # Create swerve requests for different drive modes
        self._fieldCentricRequest = (
            swerve.requests.FieldCentric()
            .with_deadband(0.05)
            .with_rotational_deadband(0.05)
            .with_forward_perspective(swerve.requests.ForwardPerspectiveValue.BLUE_ALLIANCE)
        )
        self._operatorCentricRequest = (
            swerve.requests.FieldCentric()
            .with_deadband(0.05)
            .with_rotational_deadband(0.05)
            .with_forward_perspective(swerve.requests.ForwardPerspectiveValue.OPERATOR_PERSPECTIVE)
        )
        self._brakeRequest = swerve.requests.SwerveDriveBrake()
        self._idleRequest = swerve.requests.Idle()

        # Pending request to apply in execute()
        self._pendingRequest: swerve.requests.SwerveRequest | None = None

        # Field widget for simulation/dashboard
        self._field = Field2d()
        SmartDashboard.putData("Field", self._field)

        # Track if we're running in simulation
        self._isSimulation = RobotBase.isSimulation()

        # PID controllers for trajectory following
        self._xController = PIDController(self.TRAJECTORY_X_KP, 0.0, 0.0)
        self._yController = PIDController(self.TRAJECTORY_Y_KP, 0.0, 0.0)
        self._headingController = PIDController(self.TRAJECTORY_HEADING_KP, 0.0, 0.0)
        self._headingController.enableContinuousInput(-math.pi, math.pi)  # Wrap around at ±π

    def setup(self) -> None:
        """Called by MagicBot after injection. Perform any additional setup here."""
        pass

    def setOperatorPerspectiveForwardOrientation(self, rotation: Rotation2d) -> None:
        """Set the forward orientation for operator perspective control.

        This tells the CTRE swerve library which direction is "forward"
        from the operator's perspective, allowing for intuitive field-centric
        control.

        Args:
            rotation: The rotation that defines the forward direction.
        """
        self._drivetrain.set_operator_perspective_forward(rotation)

    def zeroHeading(self) -> None:
        """Tell the CTRE drivetrain that the robot's current forward heading is directly away from the driver."""
        self._drivetrain.seed_field_centric()

    def drive(
        self,
        *,
        velocityX: meters_per_second = 0.0,
        velocityY: meters_per_second = 0.0,
        rotationRate: radians_per_second = 0.0,
    ) -> None:
        """Drive the robot using operator-centric control.

        Args:
            velocityX: Forward velocity in m/s (positive = away from driver).
            velocityY: Left velocity in m/s (positive = to driver's left).
            rotationRate: Counter-clockwise rotation rate in rad/s.
        """
        # Operator perspective rotates the command by the operator's configured forward
        self._pendingRequest = (
            self._operatorCentricRequest.with_velocity_x(velocityX)
            .with_velocity_y(velocityY)
            .with_rotational_rate(rotationRate)
        )

    def driveFieldCentric(
        self,
        *,
        velocityX: meters_per_second = 0.0,
        velocityY: meters_per_second = 0.0,
        rotationRate: radians_per_second = 0.0,
    ) -> None:
        """Drive the robot using field-centric control (global frame).

        This is used by trajectory following where commands are field-relative.

        Args:
            velocityX: Forward velocity in m/s (positive = from blue alliance to red).
            velocityY: Left velocity in m/s (positive = to left from blue alliance to red).
            rotationRate: Counter-clockwise rotation rate in rad/s.
        """
        self._pendingRequest = (
            self._fieldCentricRequest.with_velocity_x(velocityX)
            .with_velocity_y(velocityY)
            .with_rotational_rate(rotationRate)
        )

    def brake(self) -> None:
        """Set wheels to X-pattern brake configuration."""
        self._pendingRequest = self._brakeRequest

    def stop(self) -> None:
        """Stop all motors (coast)."""
        self._pendingRequest = self._idleRequest

    def followTrajectory(self, sample: SwerveSample) -> None:
        """Follow a Choreo trajectory sample.

        This method takes a trajectory sample and generates the appropriate
        chassis speeds to follow it, including feedforward velocities from
        the trajectory and feedback corrections based on position error.

        Use this with Choreo trajectories for autonomous path following.

        Args:
            sample: A SwerveSample from a Choreo trajectory containing
                    the desired pose and velocities at this point in time.
        """
        # Get the current pose of the robot
        pose = self.getPose()

        # Calculate feedback corrections to push robot back toward trajectory
        # The sample contains the target position and the feedforward velocities
        x_feedback = self._xController.calculate(pose.X(), sample.x)
        y_feedback = self._yController.calculate(pose.Y(), sample.y)
        heading_feedback = self._headingController.calculate(pose.rotation().radians(), sample.heading)

        # Combine feedforward (from trajectory) with feedback (from PID)
        speeds = ChassisSpeeds(
            sample.vx + x_feedback,  # Forward velocity + X correction
            sample.vy + y_feedback,  # Sideways velocity + Y correction
            sample.omega + heading_feedback,  # Angular velocity + heading correction
        )

        # Apply the speeds using field-relative control
        self.driveFieldCentric(velocityX=speeds.vx, velocityY=speeds.vy, rotationRate=speeds.omega)

    def resetPose(self, pose: Pose2d) -> None:
        """Reset the robot's estimated pose.

        Args:
            pose: The new pose to set.
        """
        self._drivetrain.reset_pose(pose)

    def resetHeading(self) -> None:
        """Reset the robot's heading to 0 (forward)."""
        current_pose = self.getPose()
        self._drivetrain.reset_pose(Pose2d(current_pose.translation(), Rotation2d(0)))

    def getPose(self) -> Pose2d:
        """Get the robot's current estimated pose."""
        return self._drivetrain.get_state().pose

    def getHeading(self) -> Rotation2d:
        """Get the robot's current heading."""
        return self.getPose().rotation()

    @feedback
    def headingDegrees(self) -> float:
        """Report heading in degrees to the dashboard."""
        return self.getHeading().degrees()

    @feedback
    def poseX(self) -> float:
        """Report X position to the dashboard."""
        return self.getPose().X()

    @feedback
    def poseY(self) -> float:
        """Report Y position to the dashboard."""
        return self.getPose().Y()

    def execute(self) -> None:
        """Called by MagicBot every loop iteration.

        Applies any pending swerve request and updates telemetry.
        """
        # Update simulation state if running in simulation
        if self._isSimulation:
            self._drivetrain.update_sim_state(SIM_LOOP_PERIOD, RobotController.getBatteryVoltage())

        # Apply pending request or idle if none
        if self._pendingRequest is not None:
            self._drivetrain.set_control(self._pendingRequest)
            self._pendingRequest = None
        else:
            # Default to idle if no request was made this cycle
            self._drivetrain.set_control(self._idleRequest)

        # Update field visualization
        self._field.setRobotPose(self.getPose())
