"""Swerve drivetrain using CTRE Phoenix 6 swerve API."""

import math

import wpimath.kinematics as kinematics
from choreo.trajectory import SwerveSample
from magicbot import feedback
from phoenix6 import swerve
from phoenix6.hardware import CANcoder, TalonFX
from wpilib import Field2d, RobotBase, RobotController, SmartDashboard
from wpimath.controller import PIDController
from wpimath.geometry import Pose2d, Pose3d, Rotation2d, Translation2d
from wpimath.units import meters_per_second, radians_per_second, seconds

from generated.tuner_constants import TunerConstants

# Simulation period in seconds (20ms = 0.020s for standard robot loop)
SIM_LOOP_PERIOD = 0.020


class Drivetrain:
    """Swerve drivetrain wrapper using CTRE Phoenix 6 SwerveDrivetrain.

    This class wraps the Phoenix 6 SwerveDrivetrain to integrate with MagicBot's
    component system. The Phoenix 6 API handles all the low-level control.

    Configuration is loaded from generated/tuner_constants.py which is designed
    to be regenerated by Phoenix Tuner X's Swerve Project Generator.
    """

    # PID gains for trajectory following - tune these for your robot!
    # These provide feedback to correct position error during trajectory following
    TRAJECTORY_X_KP = 10.0
    TRAJECTORY_Y_KP = 10.0
    TRAJECTORY_HEADING_KP = 7.5

    def __init__(self) -> None:
        """Initialize the swerve drivetrain with all modules."""
        # Create the Phoenix 6 SwerveDrivetrain using TunerConstants
        self._drivetrain = swerve.SwerveDrivetrain(
            TalonFX,
            TalonFX,
            CANcoder,
            TunerConstants.drivetrain_constants,
            [
                TunerConstants.front_left,
                TunerConstants.front_right,
                TunerConstants.back_left,
                TunerConstants.back_right,
            ],
        )

        # Create swerve requests for different drive modes
        self._fieldCentricRequest = (
            swerve.requests.FieldCentric()
            .with_deadband(0.05)
            .with_rotational_deadband(0.05)
            .with_forward_perspective(swerve.requests.ForwardPerspectiveValue.BLUE_ALLIANCE)
        )
        self._operatorCentricRequest = (
            swerve.requests.FieldCentric()
            .with_deadband(0.05)
            .with_rotational_deadband(0.05)
            .with_forward_perspective(swerve.requests.ForwardPerspectiveValue.OPERATOR_PERSPECTIVE)
        )
        self._brakeRequest = swerve.requests.SwerveDriveBrake()
        self._idleRequest = swerve.requests.Idle()

        # Request for driving while facing a target angle (uses internal PID)
        self._facing_angle_request = (
            swerve.requests.FieldCentricFacingAngle()
            .with_deadband(0.05)
            .with_forward_perspective(swerve.requests.ForwardPerspectiveValue.OPERATOR_PERSPECTIVE)
        )
        # Configure the heading controller for the facing angle request
        self._facing_angle_request.heading_controller.enableContinuousInput(-math.pi, math.pi)
        self._facing_angle_request.heading_controller.setP(7.5)

        # Track operator perspective for adjusting field-relative angles
        self._operator_forward: Rotation2d = Rotation2d()

        # Pending request to apply in execute()
        self._pendingRequest: swerve.requests.SwerveRequest | None = None

        # Field widget for simulation/dashboard
        self._field = Field2d()
        SmartDashboard.putData("Field", self._field)

        # Track if we're running in simulation
        self._isSimulation = RobotBase.isSimulation()

        # PID controllers for trajectory following
        self._xController = PIDController(self.TRAJECTORY_X_KP, 0.0, 0.0)
        self._yController = PIDController(self.TRAJECTORY_Y_KP, 0.0, 0.0)
        self._headingController = PIDController(self.TRAJECTORY_HEADING_KP, 0.0, 0.0)
        self._headingController.enableContinuousInput(-math.pi, math.pi)  # Wrap around at ±π

    def setOperatorPerspectiveForwardOrientation(self, rotation: Rotation2d) -> None:
        """Set the forward orientation for operator perspective control.

        This tells the CTRE swerve library which direction is "forward"
        from the operator's perspective, allowing for intuitive field-centric
        control.

        Args:
            rotation: The rotation that defines the forward direction.
        """
        self._drivetrain.set_operator_perspective_forward(rotation)
        self._operator_forward = rotation

    def zeroHeading(self) -> None:
        """Tell the CTRE drivetrain that the robot's current forward heading is directly away from the driver."""
        self._drivetrain.seed_field_centric()

    def drive(
        self,
        *,
        velocityX: meters_per_second = 0.0,
        velocityY: meters_per_second = 0.0,
        rotationRate: radians_per_second = 0.0,
    ) -> None:
        """Drive the robot using operator-centric control.

        Args:
            velocityX: Forward velocity in m/s (positive = away from driver).
            velocityY: Left velocity in m/s (positive = to driver's left).
            rotationRate: Counter-clockwise rotation rate in rad/s.
        """
        # TODO? Should we be applying x-stance if the shooter is actively shooting?
        # Not doing it yet, because we're hoping we can drive slowly enough while shooting to succeed.

        # Operator perspective rotates the command by the operator's configured forward
        self._pendingRequest = (
            self._operatorCentricRequest.with_velocity_x(velocityX)
            .with_velocity_y(velocityY)
            .with_rotational_rate(rotationRate)
        )

    def driveFieldCentric(
        self,
        *,
        velocityX: meters_per_second = 0.0,
        velocityY: meters_per_second = 0.0,
        rotationRate: radians_per_second = 0.0,
    ) -> None:
        """Drive the robot using field-centric control (global frame).

        This is used by trajectory following where commands are field-relative.

        Args:
            velocityX: Forward velocity in m/s (positive = from blue alliance to red).
            velocityY: Left velocity in m/s (positive = to left from blue alliance to red).
            rotationRate: Counter-clockwise rotation rate in rad/s.
        """
        self._pendingRequest = (
            self._fieldCentricRequest.with_velocity_x(velocityX)
            .with_velocity_y(velocityY)
            .with_rotational_rate(rotationRate)
        )

    def brake(self) -> None:
        """Set wheels to X-pattern brake configuration."""
        self._pendingRequest = self._brakeRequest

    def driveFacingAngle(
        self,
        *,
        velocityX: meters_per_second = 0.0,
        velocityY: meters_per_second = 0.0,
        targetAngle: Rotation2d,
    ) -> None:
        """Drive while rotating to face a target angle.

        Uses the CTRE FieldCentricFacingAngle request which has a built-in
        PID controller to rotate toward the target angle at maximum safe speed.

        Args:
            velocityX: Forward velocity in m/s (positive = away from driver).
            velocityY: Left velocity in m/s (positive = to driver's left).
            targetAngle: The field-relative angle to face.
        """
        # The request uses OPERATOR_PERSPECTIVE which rotates the target angle
        # by the operator's forward direction. We need to undo that rotation
        # since target_angle is already field-relative.
        adjustedAngle = targetAngle - self._operator_forward

        self._pendingRequest = (
            self._facing_angle_request.with_velocity_x(velocityX)
            .with_velocity_y(velocityY)
            .with_target_direction(adjustedAngle)
        )

    def stop(self) -> None:
        """Stop all motors (coast)."""
        self._pendingRequest = self._idleRequest

    def followTrajectory(self, sample: SwerveSample) -> None:
        """Follow a Choreo trajectory sample.

        This method takes a trajectory sample and generates the appropriate
        chassis speeds to follow it, including feedforward velocities from
        the trajectory and feedback corrections based on position error.

        Use this with Choreo trajectories for autonomous path following.

        Args:
            sample: A SwerveSample from a Choreo trajectory containing
                    the desired pose and velocities at this point in time.
        """
        # Get the current pose of the robot
        pose = self.getPose()

        # Calculate feedback corrections to push robot back toward trajectory
        # The sample contains the target position and the feedforward velocities
        xFeedback = self._xController.calculate(pose.X(), sample.x)
        yFeedback = self._yController.calculate(pose.Y(), sample.y)
        headingFeedback = self._headingController.calculate(pose.rotation().radians(), sample.heading)

        # Combine feedforward (from trajectory) with feedback (from PID)
        speeds = kinematics.ChassisSpeeds(
            sample.vx + xFeedback,  # Forward velocity + X correction
            sample.vy + yFeedback,  # Sideways velocity + Y correction
            sample.omega + headingFeedback,  # Angular velocity + heading correction
        )

        # Apply the speeds using field-relative control
        self.driveFieldCentric(velocityX=speeds.vx, velocityY=speeds.vy, rotationRate=speeds.omega)

    def resetPose(self, pose: Pose2d) -> None:
        """Reset the robot's estimated pose.

        Args:
            pose: The new pose to set.
        """
        self._drivetrain.reset_pose(pose)

    def resetHeading(self) -> None:
        """Reset the robot's heading to 0 (forward)."""
        self._drivetrain.reset_pose(Pose2d(self.getPose().translation(), Rotation2d(0)))

    def getPose(self) -> Pose2d:
        """Get the robot's current estimated pose."""
        return self._drivetrain.get_state().pose

    def getHeading(self) -> Rotation2d:
        """Get the robot's current heading."""
        return self.getPose().rotation()

    def addVisionMeasurement(
        self,
        pose: Pose3d,
        timestamp: seconds,
        stdDevs: tuple[float, float, float] = (0.5, 0.5, 0.1),
    ) -> None:
        """Add a vision measurement to the pose estimator.

        This fuses the vision measurement with wheel odometry to improve
        pose estimation accuracy. Call this for each valid vision measurement.

        Args:
            pose: The robot pose estimated by vision (Pose3d).
            timestamp: The timestamp when the image was captured (seconds).
            stdDevs: Standard deviations (x_meters, y_meters, rotation_radians).
                     Higher values = less trust in this measurement.
        """
        # Phoenix 6 SwerveDrivetrain accepts Pose2d and std devs for vision measurements
        self._drivetrain.add_vision_measurement(pose.toPose2d(), timestamp, stdDevs)

    def getVelocity(self) -> Translation2d:
        """Get the robot's current field-centric velocity as (vx, vy) in m/s."""
        speeds: kinematics.ChassisSpeeds = self._drivetrain.get_state().speeds
        # ChassisSpeeds is robot-relative, so rotate by heading to get field-relative
        robotRelativeVelocity = Translation2d(speeds.vx, speeds.vy)
        return robotRelativeVelocity.rotateBy(self.getHeading())

    def add_vision_measurement(
        self,
        pose: Pose3d,
        timestamp: seconds,
        std_devs: tuple[float, float, float] = (0.5, 0.5, 0.1),
    ) -> None:
        """Add a vision measurement to the pose estimator.

        This fuses the vision measurement with wheel odometry to improve
        pose estimation accuracy. Call this for each valid vision measurement.

        Args:
            pose: The robot pose estimated by vision (Pose3d).
            timestamp: The timestamp when the image was captured (seconds).
            std_devs: Standard deviations (x_meters, y_meters, rotation_radians).
                      Higher values = less trust in this measurement.
        """
        # Phoenix 6 SwerveDrivetrain accepts Pose2d and std devs for vision measurements
        self._drivetrain.add_vision_measurement(pose.toPose2d(), timestamp, std_devs)

    @feedback
    def headingDegrees(self) -> float:
        """Report heading in degrees to the dashboard."""
        return self.getHeading().degrees()

    @feedback
    def poseX(self) -> float:
        """Report X position to the dashboard."""
        return self.getPose().X()

    @feedback
    def poseY(self) -> float:
        """Report Y position to the dashboard."""
        return self.getPose().Y()

    def execute(self) -> None:
        """Called by MagicBot every loop iteration.

        Applies any pending swerve request and updates telemetry.
        """
        # Update simulation state if running in simulation
        if self._isSimulation:
            self._drivetrain.update_sim_state(SIM_LOOP_PERIOD, RobotController.getBatteryVoltage())

        # Apply pending request or idle if none
        if self._pendingRequest is not None:
            self._drivetrain.set_control(self._pendingRequest)
            self._pendingRequest = None
        else:
            # Default to idle if no request was made this cycle
            self._drivetrain.set_control(self._idleRequest)

        # Update field visualization
        self._field.setRobotPose(self.getPose())
