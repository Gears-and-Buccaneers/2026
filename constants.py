"""Identifiers for objects on the CAN bus(es) and physical robot dimensions.

Note: Swerve drivetrain configuration is now in generated/tuner_constants.py
which is designed to be regenerated by Phoenix Tuner X's Swerve Project Generator.
"""

from __future__ import annotations

import enum
from typing import Final

import wpilib
import wpimath.geometry as geo
import wpimath.units as units
from wpimath.geometry import Rotation3d, Transform3d, Translation3d

# Associate alliances with the field-centric rotation that is forward.
ALLIANCE_PERSPECTIVE_ROTATION: dict[wpilib.DriverStation.Alliance, geo.Rotation2d] = {
    wpilib.DriverStation.Alliance.kBlue: geo.Rotation2d.fromDegrees(0),
    wpilib.DriverStation.Alliance.kRed: geo.Rotation2d.fromDegrees(180),
}


class CANID(enum.IntEnum):
    """IDs for items on the CAN bus.

    Note: Swerve motor and encoder CAN IDs are now in generated/tuner_constants.py.
    """

    # Other motors (non-swerve)
    SHOOTER_MOTOR_TOP = 15
    SHOOTER_MOTOR_BOTTOM = 16
    FEEDER_MOTOR = 17

    SHOOTER_MOTOR_TOP_CANCODER = 18
    SHOOTER_MOTOR_BOTTOM_CANCODER = 19

    INTAKE_MOTOR = 12


# PWM port for the LED controller
LED_PWM_PORT: Final[int] = 9


class RobotDimension:
    """Physical dimensions and locations of robot components.

    Note: Swerve module locations are now in generated/tuner_constants.py.
    """

    # Shooter dimensions
    SHOOTER_Z: Final[units.meters] = 0.421
    SHOOTER_MAX_ANGLE: Final[units.radians] = units.degreesToRadians(34.0)


class ControllerPort:
    """USB ports for controllers."""

    DRIVER_CONTROLLER: Final[int] = 0
    OPERATOR_CONTROLLER: Final[int] = 1


class TeleopShift(enum.StrEnum):
    """Different shifts within the teleop period.

    Use TeleopShift.TRANSITION to refer to it by enum.
    Use TeleopShift.TRANSITION.startTime to get its start time in seconds.
    Use TeleopShift.TRANSITION.endTime to get its end time in seconds.
    """

    # fmt: off
    TRANSITION = ("transition", 140, 130)  # 2:20 – 2:10
    SHIFT1     = ("shift1",     130, 105)  # 2:10 – 1:45
    SHIFT2     = ("shift2",     105, 80)   # 1:45 – 1:20
    SHIFT3     = ("shift3",     80,  55)   # 1:20 – 0:55
    SHIFT4     = ("shift4",     55,  30)   # 0:55 – 0:30
    ENDGAME    = ("endgame",    30,   0)   # 0:30 – 0:00
    UNKNOWN    = ("-",          -1,  -1)   # Not in teleop
    # fmt: on

    # Declare extra attribute of the enum values.
    startTime: units.seconds
    endTime: units.seconds
    duration: units.seconds

    def __new__(cls, shiftName: str, startTime: units.seconds, endTime: units.seconds):
        """Create a new TeleopShift enum value from name, with start and end times."""
        obj = str.__new__(cls, shiftName)
        obj._value_ = shiftName
        obj.startTime = startTime
        obj.endTime = endTime
        obj.duration = startTime - endTime
        return obj

    @classmethod
    def byEndTime(cls) -> list[TeleopShift]:
        """Return all shifts sorted by end time, descending."""
        return sorted(cls, key=lambda s: s.endTime, reverse=True)


class PhaseDuration(enum.IntEnum):
    """Durations of different robot phases in seconds."""

    AUTONOMOUS = 15
    TELEOP = 140
    DISABLED = 0
    TEST = 0


class VisionConfig:
    """Configuration for PhotonVision cameras.

    Each camera needs:
    - A name matching the PhotonVision camera name
    - A Transform3d from robot center to camera position

    Transform3d format: Translation3d(x, y, z), Rotation3d(roll, pitch, yaw)
    - X: forward from robot center (meters)
    - Y: left from robot center (meters)
    - Z: up from robot center (meters)
    - Roll: rotation around X axis (radians)
    - Pitch: rotation around Y axis (radians) - positive = camera tilted up
    - Yaw: rotation around Z axis (radians) - positive = camera rotated left

    IMPORTANT: Update these values to match your actual camera mounting positions!
    """

    # Camera names - must match names configured in PhotonVision
    FRONT_CAMERA_NAME: Final[str] = "front_camera"
    BACK_LEFT_CAMERA_NAME: Final[str] = "back_left_camera"
    BACK_RIGHT_CAMERA_NAME: Final[str] = "back_right_camera"

    # Robot-to-camera transforms
    # Front camera: mounted on front of robot, facing forward
    FRONT_CAMERA_TRANSFORM: Final[Transform3d] = Transform3d(
        Translation3d(0.3, 0.0, 0.5),  # 30cm forward, 50cm up
        Rotation3d(0, units.degreesToRadians(-15), 0),  # Tilted down 15 degrees
    )

    # Back-left camera: mounted on back-left corner, facing backward-left
    BACK_LEFT_CAMERA_TRANSFORM: Final[Transform3d] = Transform3d(
        Translation3d(-0.3, 0.25, 0.5),  # 30cm back, 25cm left, 50cm up
        Rotation3d(0, units.degreesToRadians(-15), units.degreesToRadians(150)),  # Facing back-left
    )

    # Back-right camera: mounted on back-right corner, facing backward-right
    BACK_RIGHT_CAMERA_TRANSFORM: Final[Transform3d] = Transform3d(
        Translation3d(-0.3, -0.25, 0.5),  # 30cm back, 25cm right, 50cm up
        Rotation3d(0, units.degreesToRadians(-15), units.degreesToRadians(-150)),  # Facing back-right
    )
